Chapter 2 Introducing Data types and operators
Key skills and concepts:
-Know Java's primitive types

-Use literals

-Initialize variables

-Know the scope rules of variables within a method

-Use the arithmetic operators

-Use the relational and logical operators

-Understand the assignment operators

-Use shorthand assignments

-Understand type conversion in assignments

-Cast incompitable types

-Understand type conversion in expressions

 
Why data types are important 
Data types are especially important in Java because it is a strongly typed language.
This means that all operations are type-checked by the compiler for type compatibility.
Illegal operations will not be compiled.
Thus, strong type checking helps prevent errors and enhances reliability.
To enable strong type checking, all variables, expressions, and values have a type.
The type of a value determines what operations are allowed on it.
An operation allowed on one type might not be allowed on another.

Java's Primitive types
Java contains two general categories of built-in data types: object-oriented and non-object-oriented.
Java's object-oriented types are defined by classes.
However at the core of Java are eight primitive types of data:

Type		Meaning					Size
boolean		represents true/false values		1 bit
byte		8-bit integer				8 bits
char		Character				16 bits
double		double-precision floating point		64 bits
float		single-precision floating point		32 bits
int		Integer					32 bits
long		Long Integer				64 bits
short		short integer				16 bits

____________________________________________________________________________________________________________________________________________________________________________________________________________
Primitive data types in Java
Type	Description		Default		Size		Example Literals
boolean	true or false		false		1 bit		true, false
byte	twos complement integer	0		8 bits		(none)
char	Unicode character	\u0000		16 bits		'a', '\u0041', '\101', '\\', '\'', '\n', 'ß'
short	twos complement integer	0		16 bits		(none)
int	twos complement integer	0		32 bits		-2, -1, 0, 1, 2
long	twos complement integer	0		64 bits		-2L, -1L, 0L, 1L, 2L
float	IEEE 754 floating point	0.0		32 bits		1.23e100f, -1.23e-100f, .3f, 3.14F
double	IEEE 754 floating point	0.0		64 bits		1.23456e300d, -1.23456e-300d, 1e1d

To get the two's complement negative notation of an integer, you write out the number in binary. You then invert the digits, and add one to the result.

Suppose we're working with 8 bit quantities (for simplicity's sake) and suppose we want to find how -28 would be expressed in two's complement notation. First we write out 28 in binary form.

00011100
Then we invert the digits. 0 becomes 1, 1 becomes 0.

11100011
Then we add 1.

11100100
That is how one would write -28 in 8 bit binary.
Conversion from Two's Complement

Use the number 0xFFFFFFFF as an example. In binary, that is:

1111 1111 1111 1111 1111 1111 1111 1111
What can we say about this number? It's first (leftmost) bit is 1, which means that this represents a number that is negative. That's just the way that things are in two's complement: a leading 1 means the number is negative, a leading 0 means the number is 0 or positive.

To see what this number is a negative of, we reverse the sign of this number. But how to do that? The class notes say (on 3.17) that to reverse the sign you simply invert the bits (0 goes to 1, and 1 to 0) and add one to the resulting number.

The inversion of that binary number is, obviously:

0000 0000 0000 0000 0000 0000 0000 0000
Then we add one.
0000 0000 0000 0000 0000 0000 0000 0001
So the negative of 0xFFFFFFFF is 0x00000001, more commonly known as 1. So 0xFFFFFFFF is -1.

Conversion to Two's Complement

Note that this works both ways. If you have -30, and want to represent it in 2's complement, you take the binary representation of 30:

0000 0000 0000 0000 0000 0000 0001 1110
Invert the digits.

1111 1111 1111 1111 1111 1111 1110 0001
And add one.

1111 1111 1111 1111 1111 1111 1110 0010

Example 1

Suppose we want to add two numbers 69 and 12 together. If we're to use decimal, we see the sum is 81. But let's use binary instead, since that's what the computer uses.

1 1   
Carry Row
  0000 0000 0000 0000 0000 0000 0100 0101
(69)
+ 0000 0000 0000 0000 0000 0000 0000 1100
(12)
  0000 0000 0000 0000 0000 0000 0101 0001
(81)

Example 2

Now suppose we want to subtract 12 from 69. Now, 69 - 12 = 69 + (-12). To get the negative of 12 we take its binary representation, invert, and add one.

0000 0000 0000 0000 0000 0000 0000 1100
Invert the digits.

1111 1111 1111 1111 1111 1111 1111 0011
And add one.

1111 1111 1111 1111 1111 1111 1111 0100
The last is the binary representation for -12. As before, we'll add the two numbers together.

1111 1111 1111 1111 1111 1111 1    1   
Carry Row
  0000 0000 0000 0000 0000 0000 0100 0101
(69)
+ 1111 1111 1111 1111 1111 1111 1111 0100
(-12)
  0000 0000 0000 0000 0000 0000 0011 1001
(57)

We result in 57, which is 69-12.
Example 3

Lastly, we'll subtract 69 from 12. Similar to our operation in example 2, 12 - 69 = 12 + (- 69). The two's complement representation of 69 is the following. I assume you've had enough illustrations of inverting and adding one.

1111 1111 1111 1111 1111 1111 1011 1011
So we add this number to 12.
111     
Carry Row
  0000 0000 0000 0000 0000 0000 0000 1100
(12)
+ 1111 1111 1111 1111 1111 1111 1011 1011
(-69)
  1111 1111 1111 1111 1111 1111 1100 0111
(-57)

This results in 12 - 69 = -57, which is correct.

Why Inversion and Adding One Works

Invert and add one. Invert and add one. It works, and you may want to know why. If you don't care, skip this, as it is hardly essential. This is only intended for those curious as to why that rather strange technique actually makes mathematical sense.

Inverting and adding one might sound like a stupid thing to do, but it's actually just a mathematical shortcut of a rather straightforward computation.

Borrowing and Subtraction

Remember the old trick we learned in first grade of "borrowing one's" from future ten's places to perform a subtraction? You may not, so I'll go over it. As an example, I'll do 93702 minus 58358.

  93702
- 58358
-------
Now, then, what's the answer to this computation? We'll start at the least significant digit, and subtract term by term. We can't subtract 8 from 2, so we'll borrow a digit from the next most significant place (the tens place) to make it 12 minus 8. 12 minus 8 is 4, and we note a 1 digit above the ten's column to signify that we must remember to subtract by one on the next iteration.

     1
  93702
- 58358
-------
      4
This next iteration is 0 minus 5, and minus 1, or 0 minus 6. Again, we can't do 0 minus 6, so we borrow from the next most significant figure once more to make that 10 minus 6, which is 4.

    11
  93702
- 58358
-------
     44
This next iteration is 7 minus 3, and minus 1, or 7 minus 4. This is 3. We don't have to borrow this time.

    11
  93702
- 58358
-------
    344
This next iteration is 3 minus 8. Again, we must borrow to make thi 13 minus 8, or 5.

  1 11
  93702
- 58358
-------
   5344
This next iteration is 9 minus 5, and minus 1, or 9 minus 6. This is 3. We don't have to borrow this time.

  1 11
  93702
- 58358
-------
  35344
So 93702 minus 58358 is 35344.

Borrowing and it's Relevance to the Negative of a Number

When you want to find the negative of a number, you take the number, and subtract it from zero. Now, suppose we're really stupid, like a computer, and instead of simply writing a negative sign in front of a number A when we subtract A from 0, we actually go through the steps of subtracting A from 0.

Take the following idiotic computation of 0 minus 3:

 
000000
-    3
------

    1
000000
-    3
------
     7
   11
000000
-    3
------
    97
  111
000000
-    3
------
   997
 1111
000000
-    3
------
  9997
Et cetera, et cetera. We'd wind up with a number composed of a 7 in the one's digit, a 9 in every digit more significant than the 100's place.

The Same in Binary

We can do more or less the same thing with binary. In this example I use 8 bit binary numbers, but the principle is the same for both 8 bit binary numbers (chars) and 32 bit binary numbers (ints). I take the number 75 (in 8 bit binary that is 010010112) and subtract that from zero.

Sometimes I am in the position where I am subtracting 1 from zero, and also subtracting another borrowed 1 against it.

 
  00000000
- 01001011
----------

        1
  00000000
- 01001011
----------
         1
       11
  00000000
- 01001011
----------
        01
      111
  00000000
- 01001011
----------
       101
     1111
  00000000
- 01001011
----------
      0101
    11111
  00000000
- 01001011
----------
     10101
   111111
  00000000
- 01001011
----------
    110101
  1111111
  00000000
- 01001011
----------
   0110101
 11111111
  00000000
- 01001011
----------
  10110101
If we wanted we could go further, but there would be no point. Inside of a computer the result of this computation would be assigned to an eight bit variable, so any bits beyond the eighth would be discarded.

With the fact that we'll simply disregard any extra digits in mind, what difference would it make to the end result to have subtracted 01001011 from 100000000 (a one bit followed by 8 zero bits) rather than 0? There is none. If we do that, we wind up with the same result:

 11111111
 100000000
- 01001011
----------
 010110101
So to find the negative of an n-bit number in a computer, subtract the number from 0 or subtract it from 2n. In binary, this power of two will be a one bit followed by n zero bits.

In the case of 8-bit numbers, it will answer just as well if we subtract our number from (1 + 11111111) rather than 100000000.

         1
+ 11111111
- 01001011
----------
In binary, when we subtract a number A from a number of all 1 bits, what we're doing is inverting the bits of A. So the subtract operation is the equivalent of inverting the bits of the number. Then, we add one.

So, to the computer, taking the negative of a number, that is, subtracting a number from 0, is the same as inverting the bits and adding one, which is where the trick comes from.


Range of numeric data types in Java
Type	Size	Range
byte	8 bits	-128 .. 127
short	16 bits	-32,768 .. 32,767
int	32 bits	-2,147,483,648 .. 2,147,483,647
long	64 bits	-9,223,372,036,854,775,808 .. 9,223,372,036,854,775,807
float	32 bits	3.40282347 x 1038, 1.40239846 x 10-45
double	64 bits	1.7976931348623157 x 10308, 4.9406564584124654 x 10-324

In the IEEE 754 floating-point number standard the finite, nonzero values are of the form s · m · 2e. For words of length 32 bits s is 0 (for positive) or 1 (for negative), m is a positive integer less that 224, and e is between -127 and 128, inclusive. For words of length 64 bits s is 0 (for positive) or 1 (for negative), m is a positive integer less that 253, and e is between -1023 and 1024, inclusive.

__________________________________________________________________________________________________________________________________________________________________________________________________
Integers
Java defines four integer types: byte, short, int, and long
type	width in bits	range
byte	8		-128 to 127
short	16		-32 768 to 32 767
int	32		-2 147 483 648 to 2 147 483 647
long	64		-9,223,372,036,854,775,808 .. 9,223,372,036,854,775,807

Floating-point types
Type float 32 bits wide and type double is 64 bits wide.

Characters
In Java, characters are not 8-bit quantites like they are in many other computer languages.
Instead, Java uses Unicode.
Unicode defines a character set that can represent all of the characters found in all human languages.
___________________________________________________________________________________________________________________________________________________________________________________________________
charcter set 

ACII code for unaccented english letters ascii which is able to represent every character using a numeric number between 32 and 127. 
Space was 32, the letter "A" was 65, etc.
This could conviniently be stored in 7 bits.
Most computers in those days were using 8-bit bytes, so not only could you store ebery possible ascii character, but you had a whole bit to spare.
Codes below 32 were called unprintable and were used for control characters, like 7 which made your computer beep.
codes 128-255 are not used
For example on some PCs the character code 130 would display as é, but on computers sold in Israel it was the Hebrew letter Gimel (ג), so when Americans would send their résumés to Israel they would arrive as rגsumגs.

In the ANSI standard, everybody agreed on what to do below 128, which was pretty much the same as ascii, but there were lots of different ways to handle the characters from 128 and on up, depending on where you lived. These different systems were called code pages. So for example in Israel DOS used a code page called 862, while Greek users used 737


 
unicode
Unicode is a single character set that included every reasonable writing system on the planet.
Until now, we've assumed that a letter maps to some bits which you can store on disk or in memory
A -> 0100 0001 (65)
In Unicode, a letter maps to something called a code point which is still just a theoretical concept.
Every letter in every alphabet is assigned a number by th Unicode consortium which is written like this: U+0639.
This number is called a code point.
The U+ means "Unicode" and the numbers are hexadecimal.
The English letter A would be U+0041
There is no real limit on the number of letters that Unicode can define and in fact they have gone beyond 65,536 so not every unicode letter can really be squeezed into two bytes.
So we have a string:
			Hello
which in Unicode, corresponds to these five code points:
			U+0048 U+0065 U+006C U+006F
Encoddings
The earliest idea for Unicode encoding, which led to the myth about two bytes, was, hey, let's just store those numbers in two bytes each.
So hello becomes:
			00 48 00 65 00 6C 00 6F
COuldn't it also be:
			48 00 65 00 6C 00 6f 00
Unicode Byte Order Mark: FE FF at the beginning of every Unicode string, if you are swapping your high and low bytes it will look like FF FE

UTF-8 is system of storing a sting of Unicode code points, those U+ numbers, in memory using 8 bit bytes. 
In UTF-8, every code point from 0-1276 is stored in a single byte.
Only code points 128 and above are stored using 2, 3, in fact, up to 6 bytes.
This had the neat side effect that English text looks exactly the same in UTF-8 as it did in ASCII.
Specifically, Hello, which was U+0048 U+0065 U+006C U+006F, will be stored as 48 65 6C 6F, which is the same as it was stored in ascii
So far I've told you three ways of encoding Unicode.
The traditional store-in-two-bytes methods are called UCS-2(because it has two bytes) or UTF-8(because it has 16 bits), and you still have to figure out if it's high-endian UCS-2 or low-endian UCS-2.
And there is the popular new UTF-8 standard which has the nice property of also working respectably if you have the happy coincidence of English text.

There are actually a bunch of other ways of encoding Unicode.
There's something called UTF-7, which is a lot like UTF-8 but guarantees that the high bit will always be zero.
There's UCS-4, which stores each code point in 4 bytes, which has the nice property that every single code point can be stored in the same number of bytes.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
One idea has many possible encodings. An encoding is just a method to transform an idea (like the letter “A”) into raw data (bits and bytes). The idea of “A” can be encoded many different ways. Encodings differ in efficiency and compatibility.

ASCII and COde Pages
ASCII/ANSI characters sets map the numeric values 0-127 to various Western characters and control codes(newline, tab, etc).
Note that values 0-127 fit in the lower 7 bits in an 8-bit byte.
ASCII does not explicitly define what values 128-255 map to.

ACII encoding works great for English text (using Western characters), but the world is a big place. What about Arabic, Chinese and Hebrew?

To solve this, computer makers defined "code pages" that used the undefined space from 128-255 in ASCII, mapping it to various characters they neede.
Unfortunately, 128 additional characters aren't enough for the entire world: code pages varied by country(Russian code page, Hebrew code page, etc)

If people with the same code page exchanged data, all was good.
Character #200 on my machine was the same as Charater #200 on yours.
But if code pages mixed (Russian sender, Hebrew receiver), things got strange.
The character mapped to #200 was different in Russian and Hebrew.

Unicode
Letters are abstract concepts.
Unicode labeled each abstract character with a code point.
For example, "A" mapped to code point U+0041 (this code point is in hex; code point 65 in decimal).
COmpatipility

For compatibility with ascii, code poins U+0000 to U+007F (0-127) were the same as ASCII
The majority of common languages fit into 65535 (2 bytes, 16 bits) codepoints, which can be stored in two bytes

How do we store a codepoint as data?

Encoding
From above, encoding turns an idea into raw data. In this case, the idea is a codepoint.

For example, let's look at the ASCII "encoding" scheme to store Unicode codepoints:
1. Codepoints from U+0000 to U+007F are stored in a single byte
2. Cobepoints above U+0080 are dropped.

ASCII ignores most unicode codepoints altogether. If you have a Unicode document and save it as ascii - all your special characters are gone.

ASCII
Byte 	48 65 6C 6C 6F
Letter	H  e  l  l  o
UCS-2/UTF-16
This can handle codepoints 0x0000 to 0xFFFF, or 0-65535. (FF=255 can be stored in 1 byte)
Storing data in multiple bytes leads to byte order inconsistency. Some computers store the little byte first, others the big byte.
?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
big-endian and little-endian
Big-endian and little-endian are terms that describe the order in which a sequence of bytes are stored in computer memory
Big-endian is an order in which the "big end" (most significant value in the sequence) is stored first (at the lowest storage address).
Little-endian is an order in which the "little end" (least significant value in the sequence) is stored first.
For example, in a big-endian computer, the two bytes required for hexadecimal number 4F52 would be stored aaas 4F52 in storage (if 4F is stored at storage address 1000, for example, 52 will be at address 1001). In a little-endian system, it would be stored as 524F (52 at adress 1000, 4F at 1001)
?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
The solution was the BOM (byte order mark) header: UCS-2 encodings could write codepoint U+FEFF as a file header.
If you open a UCS-2 string and see FEFF, the data is in the right byte order and can be used directly. 
If you see FFFE, the data came from another type of machine, and needs to be converted to your architecture.
This involves swapping every byte in the file.
But unfortunately, things are not that simple.
The BOM is actually a valid UNICODE character - what if someone sent a file without a header, and that characters was actually part of the file?

This is an open issue in Unicode.
The suggestion is to avoid U+FEFF except for headers, and use alternative characters instead (there are equivalents).

Multi-byte data will have byte order issues.
ASCII never had to worry about byte order - each character was a single byte, and could not be misinterpretted. 
But realistically, if you see bytes 0xFEFF or 0xFFFE at the start of a file, it's good chance it's BOM in a Unicode textfile.

UCS-2 example

Hello-little-endian
FF FE	4800	6500	6C00	6C00	6F00
header	H	e	l	l	o

Hello big-endian

FE FF 	0048	0065	006C	006C	006F
header	H	e	l	l	o

Observations:
	Thea header BOM (U+FEFF) shows up as expected: FFFE for little-endian, FEFF for big
	Letters use two bytes no matter what: "H" is 0x48 in ASCII, and 0x0048in UCS-2
	Encoding is simple. Take the codepoint i hex and write it out in 2 bytes, No extra processing required.
	The encoding is too simple. It wastes space for plain ASCII text that does not use the high-order byte. And ASCII text is very common
	The encoding inserts null bytes (0x00) which can be a problem. Old-school ASCII programs may think the Unicode string has ended when it gets to the null byte. On a little-endian machine, reading one byte at a time, you'd get to H (H=0x4800) and then hit the null and stop. On a big endian machine, you'd hit the null first (H is 0x0048) and not even see the H in ASCII.

UTF-8
UCS-2/UTF-8 is nice and simple, but it doubles ASCII, the converted ASCII might not even be readable due to the null character

UTF-8's goal is to encode Unicode characters in single byte where possible (ASCII), and not break ASCII applications by having null characters.

	-Code points 0-007F are stored as regular, single-byte ASCII.
	-Code points 0080 and above are converted to binary and stored (encoded) in a series of bytes.
	- The first "count" byte indicates the number of bytes for the codepoint, including the count byte.These bytes start with 11..0:

	110xxxxx (The leading "11" is indicates 2 bytes in sequence, including the "count" byte)
	1110xxxx (1110 -> 3 bytes in sequence)
	11110xxx (11110 -> 4 bytes in sequence)
	
	-Bytes starting with 10... are "data" bytes and contain information for the codepoint. A 2-byte example looks like this
		110xxxxx 10xxxxxx
	This means there are two bytes in the sequence. the x's represent the binary value of the codepoint, which needs to squeeze in remaining bits.

Observations abt UTF-8
-No null bytes. All ASCII characters (0-127) are the same. Non-ASCII characters all starts with "1" as the highest bit.
-ASCII text is storeed identically and efficiently.
-Unicode characters start with 1 as the high bit, and can be ignored by ASCII-only programs
- There is a time-space tradeoff. There is processing to be done on every Unicode character, but this is a reasonable tradeoff. 
____________________________________________________________________________________________________________________________________________________________________________________________________
In Java, char is an unsigned 16-bit type having a range of 0 to 65536. 
The standard 8-bit ASCII character set is a subset of Unicode and ranges from 0 to 127.
Thus, ASCII characters are still valid in Java characters.
A character variable can be assigned a value by enclosing the character in single quotes. For example, this assigns the variable ch the letter X:

char ch;
ch = 'X'
Since char is an unsigned 16-bit type, it is possible to perform various arithmetic manipulations on a char variable.

The Boolean type
The boolean type represents true/false values 

Literals
Literals refer to fixed values that are represented in their human-readable form.
For example, the number 100 is a literal.
Literals are also commonly called constants.
Java literals can be of any of the primitive data types. 
The way each literal is represented depends upon its type.
As explained earlier, character constants are enclosed in single quotes.
For example, 'a' and '%' are both character constants.
Integer literals are specified as numbers without fractional components.
For example, 10 and -100 are integer literals.
Floating-point literals require the use of the decimal point followed by the number's fractional component.
For example, 11.123 is a floating-point literal.
Java also allows you to use scientific notation for floating-point numbers.
By default, integer literals are of type int.
If you want to specify a long literal, append an l or an L.
For example, 12 is an int, but 12L is a long.
By default, floating-point literals are of type double.
To specify a float literal, append an F or f to the constant. For example, 10.19F is of tyoe float.
Although integer literals create an int valueby default, they can still be assigned to variables of type char, byte, or short as long as the value being assigned can be represented by the target type.
An integer literal can always be assigned to a long variable.
You can embed one or more underscores into an integer or floating-point literal: 123_451_234 specifies the value 123451234


Hexadecimal, Octal, and Binary literals
Java allows you to specify integer literals in hexadecimal or octal instead of decimal.
A hexadecimal literal must begin with 0x or 0X (a zero followed by an x or X).
An octal literal begins with a zero.
hex = 0xFF //255 in decimal
oct = 011 // 9 in decimal
Java also allows hexadecimal floating-point literals.
It is possible to specify an integer literal by use of binary.
To do so precede the binary number with a 0b or 0B.
For example, this specifies the value 12 in binary: 0b1100

Character escape sequences
Enclosing character constants in single quotes works for most printing characters, but a few characters, such as carriage return, pose a special problem when text editor is used.
In addition, certain other characters, such as the single and double quotes, have special meaning in Java, so you cannot use them directly.

Escape sequence		Description
\'			Single quote
\"			Double quote
\\			Backslash
\r			Carriage return
\n			New line
\f			Form feed
\t			horizontal tab
\b			backspace
\ddd			octal constant (where ddd is an octal constant)
\uxxxx			hexadecimal constant (where xxxx is a hexadecimal constant) 


String literals
A string is a set of characters enclosed by double quotes.
For example, "this is a test" is a string

Is a string consisting of a single character the same as a character literal? For example, is "k" the same as 'k'?
No. A character literal represents a single letter of type char. 
A string containing only one letter is still a string. 
Although strings consist of characters, they are not the same type.

A closer look at Variables
Variables are declared using this form:

type var-name;

where type is the data type of the variable, and var-name is its name.
You can declare a variable of any valid type, including the simple types just described, and every variable will have a type.
Thus, the capabilities of a variable are determined by its type.
For example, a variable of type boolean cannot be used to store floating-point values.
Furthermore, the type of a variable cannot change during its lifetime.
An int variable cannot turn into a char variable, for example.
All variables in Java must be declared prior to their use.
This is necessary because the compiler must know what type of data a variable contains before it can properly compile any statement that uses the variable.
It also enables Java to perform strict type checking.

Initializing a Variable
In general, you must give a variable a value prior to using it. 
One way to give a variable a value is through an assignment statement, as you have already seen.
Another way is by giving it an initial value when it is declared. 
To do this, follow the variable’s name with an equal sign and the value being assigned.
The general form of initialization is shown here:
type var = value;
Here, value is the value that is given to var when var is created.
The value must be compatible with the specified type.
int count = 10; //give count an initial value of 10
char ch = 'X'; //initialize ch with the letter X
float f = 1.2F // f is initialized with 1.2

Dynamic initialization
Although the preceding examples have used only constants as initializers, JAva allows variables to be initialized dynamically, using any expression valid at the time the variable is declared.
public class DynInit {
    public static void main(String[] args) {
        double radius = 4, height = 5;

        // dynamically initialize volume
        double volume = 3.1416 * radius * radius * height;

        System.out.println("Volume is " + volume);
    }
}
Here, three local variables—radius, height, and volume—are declared. 
The first two, radius and height, are initialized by constants. 
However, volume is initialized dynamically to the volume of the cylinder. 
The key point here is that the initialization expression can use any element valid at the time of the initialization, 
including calls to methods, other variables, or literals.

The Scope and Lifetime of Variables 
A block defines a scope.
Thus, each time you start a new block, you are creating a new scope.
A scope determines what objects are visible to other parts of your program.
It also determines the lifetime of those objects. 
Some other computer languages define two general categories of scopes: global and local.
Although supported by Java, these are not the best ways to categorize Java’s scopes.
The most important scopes in Java are those defined by a class and those defined by a method.
The scope defined by a method begins with its opening curly brace. 
However, if that method has parameters, they too are included within the method’s scope.
As a general rule, variables declared inside a scope are not visible (that is, accessible) 
to code that is defined outside that scope. 
Thus, when you declare a variable within a scope, you are localizing that variable 
and protecting it from unauthorized access and/or modification. 
Indeed, the scope rules provide the foundation for encapsulation.

Scopes can be nested. For example, each time you create a block of code, you are creating a new,
nested scope. When this occurs, the outer scope encloses the inner scope. This means that objects
declared in the outer scope will be visible to code within the inner scope. However, the reverse is
not true. Objects declared within the inner scope will not be visible outside it.

Here is another important point to remember: variables are created when their scope is entered,
and destroyed when their scope is left. This means that a variable will not hold its value once it has
gone out of scope. Therefore, variables declared within a method will not hold their values between
calls to that method. Also, a variable declared within a block will lose its value when the block is
left. Thus, the lifetime of a variable is confined to its scope.

If a variable declaration includes an initializer, that variable will be reinitialized each time the
block in which it is declared is entered. 
    public static void main(String[] args) {
        int x;
        for(x = 0; x < 3; x++) {
            int y = -1; //y is initialized each time block is entered
            System.out.println("y is: " + y);
            y = 100;
            System.out.println("y is now: " + y);
        }
    }

As you can see, y is always reinitialized to -1 each time the inner for loop is entered.
Even though is it susequently assigned the value 100, this value is lost.

There is one quirk to Java’s scope rules that may surprise you: although blocks can be nested, no
variable declared within an inner scope can have the same name as a variable declared by an
enclosing scope. For example, the following program, which tries to declare two separate variables
with the same name, will not compile
public class NestVar {
//This program attempts to declare a variable in an inner scope with same name
// as one defined in an outer scope

    public static void main(String[] args) throws InterruptedException {
        int count;

        for(count = 0; count < 10; count = count+1) {
            System.out.println("This is count: " + count);

            int count; // illegal!!!
            for(count = 0; count < 2; count++)
                System.out.println("This program is in error!");
        }

    }
}
Operators
 An operator is a symbol that tells the compiler to perform
a specific mathematical or logical manipulation. Java has four general classes of operators:
arithmetic, bitwise, relational, and logical.
Arithmetic OPerators
Operator	Meaning
+		Addition (also unary plus)
-		Subtraction(also unary minus)
*		Multiplication
/		Division
%		Modulus
++		Increment
--		Decrement
The operators +,-,*, and / all work the same way in Java as the do in algebra.
These can be applied to any built-in numeric data type.
They can also be used on an object of type char.
Remember taht when / is applied to an integer, any remainder will be truncated;
for example, 10/3 will equal 3 in integer division.
10 % 3 = 1
10.0 % 3.0 = 1.0
The % yields a remainder of 1 for both integer and floating-point operations.

Incremant and Decrement
The increment operator adds 1 to its operand, and the decrement operator subtracts 1. Therefore,
x = x + 1;
is the same as
x++;
and
x = x - 1;
is the same as
x--;
Both the increment and decrement operators can either precede (prefix) or follow (postfix) the operand.
For example,
x = x + 1;
can be written as
++x; //prefix form
or as
x++; //posfix form
In the foregoing example, there is no difference whether the increment is applied as a prefix or a postfix.
However, when an increment or decrement is used as part of a larger expression, there is an important differnce.
When an increment or decrement operator precedes its operand, Java will perform the corresponding operation prior to obtaining the opernd's value for use by the rest of the expression. If the operator follows its operand, Java will obtain the operands value before incrementing or decrementing it. Consider the following:

x = 10;
y = ++x;

In this case, y will be set to 11. However, if the code is written as

x = 10;
y = x++;

then y will be set to 10. 
In both cases, x is still set to 11; the difference is when it happens.

Relational and Logical Operators
In the terms relational operator and logical operator, relational refers to the relationships that values can have with one another, and logical refers to the way in which true and false values can be connected together.
The outcome of the relational and logical operators is a boolean value. 

Short-Circuit Logical Operators
Java supplies special short-circuit versions of its AND and OR logical operators that can be used to
produce more efficient code. To understand why, consider the following. In an AND operation, if the
first operand is false, the outcome is false no matter what value the second operand has. In an OR
operation, if the first operand is true, the outcome of the operation is true no matter what the value of
the second operand. Thus, in these two cases there is no need to evaluate the second operand. By not
evaluating the second operand, time is saved and more efficient code is produced.
The short-circuit AND operator is &&, and the short-circuit OR operator is ||.
Their normal counterparts are & and |.
The only difference between the normal and short-circuit versions is that the normal operands will always evaluate each operand, but short-circuit versions will evaluate the second operand only when necessary.
The formal specification for Java refers to the short-circuit operators as the conditional-or and the conditional-and operators.

The assignment operator
The assignment operator is the single equal sign, =.
var = esxpression;
Here, the type of var must be compatible with the type of expression.
Asignment operator allows you to create a chain of assignments:
int x, y, z;

x = y = z = 100;
This works because the + is an operator that yields the value of the right-hand expression.
Thus, the value of z = 100 is 100, which is the assigned to y, which in turn is assigned to x..

Shorthand assignment
a += 10
var operator = expression;

Type conversion in assignments
In programming, it is common to assign one type of variable to another. 
For example, you might want to assign an int value to a float variable, as shown here:

int i;
float f;

i = 10;
f = i; // assign an int to a float

WHen compatible types are mixed in an assignment, the value of the right side is automatically converted to the type of the left side.
Thus, in the preceding fragment, the value in i is converted into a float and then assigned to f.
However, because of Java's strict type checking, not all types are compatible, and thus, not all type conversions are implicitly allowed.
For example, boolean and int are not compatible.

When one type of data is assigned to another type of variable, an automatic type conversion will
take place if
-The two types are compatible.
-The destination type is larger than the source type.
When these two conditions are met, a widening conversion takes place. 
For example, the int type is always large enough to hold all valid byte values, and both int and byte are integer types, so an automatic conversion from byte to int can be applied.
For widening conversions, the numeric types, including integer and floating-point types, are compatible with each other.
There are no automatic conversions from the numeric types to char or boolean. 
Also, char and boolean are not compatible with each other. 
However, an integer literal can be assigned to char(16 bits unsigned).
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
COnversions:Widening and Narrowing

to		from
		
		byte	short	char	int	long	float	double

byte		id	  -	  - 	 -	 -	  -	  -
short           +	  id	  -	 -       -        -       -
char		-	  - 	  id	 - 	 -	  -	  -
int		+	  +	  +	 id	 -	  -	  -
long		+	  +	  +	 +	 id	  -	  -
float		+	  +	  +	 +	 +	  id	  -
double		+	  +	  +	 +	 +	  +	  id



Widenings

to		from

		byte		short			char			int	long	float
		-128...127	-32 768...32 767	\u0000...\uFFFF		-1	-1	1.2
________________________________________________________________________________________________________
short		-128...127	[id]			-			 -	 -	 -
int		-128...127*	-32,768...32,767*       0...65,535+		id	 -	 -
long		-128...127*	-32,768...32,767*	0...65,535+		-1	 id	 -
float		-128.0...127.0	-32,768.0...32,767.0	0...65,535.0		-1.0p	 -1.0p	 id
double		-128.0...127.0	-32,768.0...32,767.0	0...65,535.0		-1.0	 -1.0p	 1.2
* sign extend (two's complement)

+ zero fill

p IEEE round-to-nearest integer, possible loss of precision
With the exception of boolean, any primitive type can be converted to any other. But there might be significant loss of data. Those conversions that may lose data are called narrowing are must be explicited demanded by the programmer using a cast. The following table suggests how these conversions are performed.

Of course, the programmer must be aware of the finite limits of the arithemetic data types regardless of which one is chosen. There are no byte and short operations so all these values are promoted first to int. When stored back in byte and short variables the programmer must use a cast (a narrowing) and prepare for possible loss of data.

The conversion causing the most trouble is the char to short conversion. Since they are both 16 bits it is tempting to convert chars to shorts to do arithmetic. But a twos-complement 16-bit number is both positive and negative and asymetric on top of that. Whereas the char type is most naturally considered a simple enumeration beginning with zero. In all cases the int type, not the short type is the one to choose for manipulating the bits of characters. These applies to those cases involving byte IO of text data; there is no unsigned data in Java. The data type byte is not unsigned; it supports a small range of positive and negative numbers.

Narrowings
to		from

		byte			short				char			int 		long		float	double
		-128..-1,0,1,..127	-32,768..-1,0,1,..32767		\u0000..\uFFFF		-1,0,1		-1,0,1		1.2	7.89

byte		id			0..-1,0,1..-1			0..-1			-1,0,1d		-1,0,1d		(int)	(int)	
short					id				0..-1			-1,0,1d		-1,0,1d		(int)	(int)
char		\uFF80..\uFFFF,\u0000,	\u8000..\uFFFF,\u0000,		id			\uFFFF,\u0000,	\uFFFF,\u0000	(int)	(int)
		\u0001,..\u007F		\u0001..\u7FFF						\u0001		\u0001
int		+			+				+			id		-1,0,1		1r	7r
long		+			+				+			+		id		1r	7r
float		+			+				+			+		+		id	7.89r
double		+			+				+			+		+		+	id

d discard all but n lowest order bits

r IEEE round-to-nearest
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Casting Incompatible types
Although the automatic type conversions are helpful, they will not fulfill all programming needs because they apply only to widening conversions between compatible types. 
For all other cases you must employ a cast. 
A cast is an instruction to the compiler to convert one type into another. 
Thus, it requests an explicit type conversion. A cast has this general form:
(target-type) expression
Here, target-type specifies the desired type to convert the specified expression to.
For example, if you want to convert the type of the expression x/y to int, you can write

double x,y;
//...
(int) (x / y);
Here, even though x and y are of type double, the cast converts the outcome of the expression to int.
The parantheses surrounding x / y are necessary.
otherwise, the cast to int would apply only to the x and not to the outcome of the division. 
The cast is necessary here because there is no automatic conversion from double to int.

When a cast involves a narrowing conversion, information might be lost. 
For example, when casting a long into a short, information will be lost if the long’s value is greater than the range of a short because its high-order bits are removed.
When a floating-point value is cast to an integer type, the fractional component will also be lost due to truncation. 
For example, if the value 1.23 is assigned to an integer, the resulting value will simply be 1. The 0.23 is lost.

public class CastDemo {
    public static void main(String[] args) {
        double x, y;
        byte b;
        int i;
        char ch;

        x = 10.0;
        y = 3.0;

        i = (int) (x / y); //cast double to int
        System.out.println("integer outcome of x/y: " + i);

        i = 100;
        b = (byte) i; //no loss of info here. A byte can hold the value 100.
        System.out.println("Value of b: " + b);

        i = 257;
        b = (byte) i; //information loss this time. A byte cannot hold the value 257;
        System.out.println("Value of b: " + b);

        b = 88; //ascii code for X
        ch = (char) b;
        System.out.println("ch: " + ch);
    }
}


The output
Integer outcome of x / y: 3
Value of b: 100
Value of b: 1
ch: X

In the program, the cast of (x/y) to int results in the truncation of the fractional component, and information is lost.
Next, no loss of information occurs when b is assigned the value 100 because a byte can hold tha value 100.
However, when the attempt is made to assign b the value 257, information loss occurs bcs 257 exceeds a byte's maximum value (255).
Finally, no information is lost, but a cast is needed when asigning a byte value to char.

Operator precedence
Operator Precedence
table shows the order of precedence for all Java operators, from highest to lowest

++(postfix)	--(postfix)
++(prefix)	--(prefix)	~	!	+(unary)	-(unary)	(type-cast)
*		/		%
+		-
>>		>>>		<<
>		>=		<	<=	instanceof
==		!=
&
^
|
&&
||
?:
->
=		op=


Expressions
 
Within an expression, it is possible to mix two or more different types of data as long as they are compatible with each other. 
For example, you can mix short and long within an expression because they are both numeric types. 
When different types of data are mixed within an expression, they are all converted to the same type. 
This is accomplished through the use of Java’s type promotion rules.
First, all char, byte, and short values are promoted to int. 
Then, if one operand is a long, the whole expression is promoted to long. 
If one operand is a float operand, the entire expression is promoted to float. 
If any of the operands is double, the result is double.
It is important to understand that type promotions apply only to the values operated upon when an expression is evaluated. 
For example, if the value of a byte variable is promoted to int inside an expression, outside the expression, the variable is still a byte. 
Type promotion only affects the evaluation of an expression.
Type promotion can, however, lead to somewhat unexpected results. 
For example, when an arithmetic operation involves two byte values, the following sequence occurs:
First, the byte operands are promoted to int. 
Then the operation takes place, yielding an int result. 
Thus, the outcome of an operation involving two byte values will be an int. 
This is not what you might intuitively expect.

public class PromDemo {
    public static void main(String[] args) {
        byte b;
        int i;

        b = 10;
        i = b * b; //No cast needed because result is already evaluated to int

        b = 10;
        b = (byte) (b * b); //Cast is needed here to assign an int to a byte

        System.out.println("i and b: " + i + " " + b);

    }
}
Somewhat counterintuitevly, no cast is needed when assigning b*b to i, because b is promoted to int when the expression is evaluated.
However, when you try to assign b * b to b, you do need a cast - back t byte!
Keep this in mind if you get unexpected type-incompatibility error messages on expressions that would otherwise seem perfectly OK.

This same sort of situation also occurs when performing operations on chars.
For example, in the following fragment, the cast back to char is needed because of the promotion of ch1 and ch2 to int within the expression:

char ch1 = 'a', ch2 = 'b';
ch1 = (char) (ch1 + ch2);
 Without the cast, the result of adding ch1 to ch2 would be int, which can’t be assigned to a char.

Spacing and Parantheses
An expressions in Java may have tabs and spaces in it to make it more readable.

Parantheses increase the precedence of the operations contained within them, just like in algebra.


Chapter 2 Self Test
1. Why does Java strictly specify the range and behavior of its primitive types?
security, to ensure portability across platforms
2. What is Java’s character type, and how does it differ from the character type used by some other
programming languages?
Java's charcter type is char
Java characters are unicode rather than ascii, which is used by some other computer languages
3. A boolean value can have any value you like because any non-zero value is true. True or False?
False. A boolean value must be either true or false
4. Given this output,
One
Two 
Three
using a single string, show the println( ) statement that produced it.
5. What is wrong with this fragment?
for (i = 0; i < 10; i++){
	int sum;
	sum = sum + i;
}
System.out.println("Sum is: " + sum)

sum variable is out of scope, available only inside inner block. Inside for-loop sum is not initialized
There are to fundamental flaws in the fragment. First, sum is created each time the block defined by for loop is entered and destroyed on exit. 
thus, it will not hold its value between iterations. Attempting to use sum to hold a running sum of the iterations is pointless.
Second, sum will not be known outside of the block in which it is declared. Thus, the reference to it in the println( ) statement is invalid.
6. Explain the difference between the prefix and postfix forms of the increment operator.
postfix will first use the value of variable and then increment it, prefix first increments and then uses variable
When the increment operator preceeds its operand, Java will perform the increment prior to obtaining the operand's value
for use by the rest of the expression. 
If the operator follows its operand, then Java will obtain the operand's value before incrementing.

7. Show how a short-circuit AND can be used to prevent a divide-by-zero error.
if we first check whether the value of variable is zero or not and then perform division by that variable 
if (b !=0 && val/b)
8. In an expression, what type are byte and short promoted to?
int
9. In general, when is a cast needed?
in narrowing conversion. To convert one type to another
A cast is needed when converting between incompatible types or when a narrowing conversion is occuring
10. Write a program that finds all of the prime numbers between 2 and 100.
11. Does the use of redundant parentheses affect program performance?
No
12. Does a block define a scope
Yes

